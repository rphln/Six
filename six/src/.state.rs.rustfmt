use std::fmt::Debug;
use std::ops::RangeBounds;

use crate::buffer::Buffer;
use crate::cursor::{Bounded, Line, Codepoint, Cursor, Head,  Tail};

pub enum Key<'a> {
    Esc,

    Left,
    Right,
    Up,
    Down,

    Backspace,
    Delete,

    Char(char),

    Ctrl(&'a Key<'a>),
    Shift(&'a Key<'a>),
    Meta(&'a Key<'a>),
}

/// An event.
#[derive(Copy, Clone)]
pub enum Event {
    Escape,
    Insert,

    Left,
    Right,
    Up,
    Down,

    Backward,
    Forward,

    Bol,
    Eol,

    Head { reverse: bool},
    Tail { reverse: bool},

    Delete,
    Surround,

    Char(char),
}

// TODO: Replace with a trait alias once it stabilizes.
pub trait Callback<Arg>: FnOnce(&mut State, Arg) -> Result<Mode, Mode> + Send + Sync + 'static {}

impl<Arg, F> Callback<Arg> for F where F: FnOnce(&mut State, Arg) -> Result<Mode, Mode> + Send + Sync + 'static {}

/// An modal editor.
#[derive(Debug, Derivative)]
#[derivative(Default)]
pub struct Editor {
    /// The state shared between modes.
    state: State,

    /// The current mode.
    mode: Mode,
}

/// The state state.
#[derive(Debug, Default)]
pub struct State {
    /// The state buffer.
    buffer: Buffer,

    /// The cursor position.
    cursor: Cursor,
}

/// An state mode.
#[derive(Derivative)]
#[derivative(Default, Debug)]
pub enum Mode {
    /// The default editor mode.
    #[derivative(Default)]
    Normal,

    /// The text insertion mode.
    Insert,

    /// Queries the user for a text range.
    Select {
        /// The fixed point of the selection.
        anchor: Cursor,
    },

    /// Queries the user for a text object and applies an operation.
    Operator {
        /// The operator name.
        name: &'static str,

        /// Operator to be executed.
        #[derivative(Debug = "ignore")]
        and_then: Box<dyn Callback<(Cursor, Cursor)>>,
    },

    /// Queries the user for a text input and applies an operation.
    Query {
        /// The operation name.
        name: &'static str,

        /// The buffer of the query.
        buffer: Buffer,

        /// Cursor position in the buffer.
        cursor: Cursor,

        /// Whether to finish the query.
        #[derivative(Debug = "ignore")]
        until: fn(&str, Event) -> bool,

        /// Function to be called after the input is submitted.
        #[derivative(Debug = "ignore")]
        and_then: Box<dyn for<'a> Callback<&'a str>>,
    },
}

impl Editor {
    /// Returns a reference to the state inner state.
    #[must_use]
    pub fn state(&self) -> &State {
        &self.state
    }

    /// Returns a reference to the state mode.
    #[must_use]
    pub fn mode(&self) -> &Mode {
        &self.mode
    }

    pub fn handle_key(&mut self, input: Key) {
        // TODO: Replace this with a dynamic lookup.
        let events = match (self.mode(), input) {
            (Mode::Insert{..}, Key::Char(ch))             => vec![Event::Char(ch), Event::Forward],
            (Mode::Insert { ..}, Key::Esc)                => vec![Event::Escape, Event::Left],
            (Mode::Insert{..}, Key::Backspace)            => vec![Event::Left, Event::Delete],

            (Mode::Insert{..}, Key::Ctrl(Key::Char('a'))) => vec![Event::Bol],
            (Mode::Insert{..}, Key::Ctrl(Key::Char('e'))) => vec![Event::Eol],

            (_, Key::Char('i'))                           => vec![Event::Insert],
            (_, Key::Char('a'))                           => vec![Event::Insert, Event::Right],

            (_, Key::Backspace)                           => vec![Event::Backward],

            (_, Key::Esc)                                 => vec![Event::Escape],
            (_, Key::Delete)                              => vec![Event::Delete],

            (_, Key::Left) | (_, Key::Char('h'))          => vec![Event::Left],
            (_, Key::Down) | (_, Key::Char('j'))          => vec![Event::Down],
            (_, Key::Up) | (_, Key::Char('k'))            => vec![Event::Up],
            (_, Key::Right) | (_, Key::Char('l'))         => vec![Event::Right],

            (_, _)                                        => vec![],
        };

        self.advance(events.as_slice())
    }

    /// Advances the state state by handling events.
    pub fn advance(&mut self, events: &[Event]) {
        self.mode= events.iter().try_fold(std::mem::take(&mut self.mode), |mode, &event| {
            mode.advance(&mut self.state, event)
        }).unwrap_or_else(|mode| mode);
    }
}

impl State {
    /// Returns the cursor position.
    #[must_use]
    pub fn cursor(&self) -> Cursor {
        self.cursor
    }

    /// Returns a reference to the buffer.
    #[must_use]
    pub fn buffer(&self) -> &Buffer {
        &self.buffer
    }

    pub fn set_cursor(&mut self, cursor: Cursor) {
        self.cursor = cursor;
    }

    pub fn insert(&mut self, at: Cursor, ch: char) {
        self.buffer.insert(at, ch)
    }

    pub fn replace_range(&mut self, range: impl RangeBounds<usize>, text: &str) {
        self.buffer.replace_range(range, text)
    }
}

impl Mode {
    #[must_use]
    pub fn escape() -> Mode {
        Mode::Normal
    }

    #[must_use]
    pub fn insert() -> Mode {
        Mode::Insert
    }

    pub fn operator(name: &'static str, and_then: impl Callback<(Cursor, Cursor)>) -> Mode {
        Mode::Operator { name, and_then: Box::new(and_then) }
    }

    #[must_use]
    pub fn query(
        name: &'static str,
        until: fn(&str, Event) -> bool,
        and_then: impl for<'r> Callback<&'r str>,
    ) -> Mode {
        Mode::Query {
            name,
            until,

            cursor: Cursor::default(),
            buffer: Buffer::default(),

            and_then: Box::new(and_then),
        }
    }

    /// Returns an user-friendly name for the mode.
    #[must_use]
    pub fn name(&self) -> &str {
        match self {
            Mode::Normal { .. } => "Normal",
            Mode::Insert { .. } => "Insert",
            Mode::Select { .. } => "Select",

            Mode::Query { name, .. } => name,
            Mode::Operator { name, .. } => name,
        }
    }

    /// Advances the state state by handling an event.
    pub fn advance(self, state: &mut State, event: Event) -> Result<Mode, Mode> {
        use Mode::{Insert, Normal, Operator, Query};

        match (self, event) {
            (_, Event::Escape) => Ok(Mode::escape()),
            (_, Event::Insert) => Ok(Mode::insert()),

            (Query { mut buffer, until, name, mut cursor, and_then }, event) => {
                match event {
                    Event::Char(ch) => {
                        buffer.insert(cursor, ch);
                        cursor = cursor
                            .iter::<Codepoint>(&buffer)
                            .next()
                            .unwrap_or_else(|| Cursor::eof(&buffer));
                    },

                    _ => (),
                };

                if until(buffer.as_str(), event) {
                    and_then(state, buffer.as_str())
                } else {
                    Ok(Query { buffer, until, name, cursor, and_then })
                }
            },

            (mode, Event::Forward) => {
                if let Some(cursor)= state.cursor.iter::<Codepoint>(state.buffer()).next() {
                    state.set_cursor(cursor);

                    Ok(mode)
                } else {
                    Err(mode)
                }
            },

            (mode, Event::Backward) => {
                state.set_cursor(
                    state
                        .cursor()
                        .iter::<Codepoint>(state.buffer())
                        .next_back()
                        .unwrap_or(state.cursor()),
                );

                Ok(mode)
            },

            (mode, Event::Left) => {
                state.set_cursor(
                    state
                        .cursor()
                        .iter::<Bounded>(state.buffer())
                        .next_back()
                        .unwrap_or(state.cursor()),
                );

                Ok(mode)
            },

            (mode, Event::Right) => {
                state.set_cursor( state.cursor().iter::<Bounded>(state.buffer()).next().unwrap_or(state.cursor()),);
Ok(mode)
            },

            (mode, Event::Down) => {
                state.set_cursor( state.cursor().iter::<Line>(state.buffer()).next().unwrap_or(state.cursor()),);
Ok(mode)
            },

            (mode, Event::Up) => {
                state.set_cursor( state.cursor().iter::<Line>(state.buffer()).next_back().unwrap_or(state.cursor()),);
Ok(mode)
            },

            (Normal, Event::Delete) => {
                Ok(Mode::operator("Delete", |state: &mut State, range: (Cursor, Cursor)| {
                    state.replace_range(range.0.offset()..range.1.offset(), "");
                    Ok(Mode::escape())
                }))
            },

            (mode, Event::Bol) => {
                state.set_cursor( state.cursor().iter::<Bounded>(state.buffer()).rev().last().expect("first"));
                Ok(mode)
            },

            (mode, Event::Eol) => {
                state.set_cursor( state.cursor().iter::<Bounded>(state.buffer()).last().expect("last"));
                Ok(mode)
            },

            (mode, Event::Char(ch)) => {
                state.insert(state.cursor(), ch);
                Ok(mode)
            },

            (Normal, Event::Surround) => {
                let surround = |_: &mut State, (start, end): (Cursor, Cursor)| {
                    let surround = move |state: &mut State, sandwich: &str| {
                        let mut chars = sandwich.chars();

                        let prefix = chars.next().expect("prefix");
                        let suffix = chars.next().expect("suffix");

                        state.insert(end, suffix);
                        state.insert(start, prefix);

                        Ok(Mode::escape())
                    };

                    Ok(Mode::query("Surround", |buf: &str, _: Event| buf.len() == 2, surround))
                };

                Ok(Mode::operator("Surround", surround))
            },

            (mode , Event::Head { reverse: true}) => {
                let end = state.cursor();
                state.set_cursor(
                    state
                        .cursor()
                        .iter::<Head>(state.buffer())
                        .next_back()
                        .unwrap_or_else(|| state.cursor()),
                );

                if let Operator { and_then, .. } = mode {
                    and_then(state, ( state.cursor(), end))
                } else {
                Ok(mode)
                }
            },

            (mode , Event::Head { reverse: false}) => {
                let start = state.cursor();
                state.set_cursor(
                    state
                        .cursor()
                        .iter::<Head>(state.buffer())
                        .next()
                        .unwrap_or_else(|| Cursor::eof(state.buffer())),
                );

                if let Operator { and_then, .. } = mode {
                    and_then(state, (start, state.cursor()))
                } else {
                Ok(mode)
                }
            },

            (mode, _) => Err(mode),
        }
    }
}
